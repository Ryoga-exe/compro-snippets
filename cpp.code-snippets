{
	"main-cpp": {
		"prefix": "cpp",
		"body": [
				"#include <bits/stdc++.h>",
				"#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)",
				"#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)",
				"#define rep(i, n) FOR(i,0,n)",
				"#define irep(i, n) IFOR(i,0,n)",
				"#define all(v) begin(v), end(v)",
				"using namespace std;",
				"using ll = long long;",
				"using ull = unsigned long long;",
				"using P = pair<int, int>;",
				"using PLL = pair<ll, ll>;",
				"using VI = vector<int>;",
				"using VLL = vector<ll>;",
				"using VB = vector<bool>;",
				"using VP = vector<P>;",
				"using Graph = vector<vector<int>>;",
				"template<typename T>istream& operator>>(istream&i,vector<T>&v){rep(j,v.size())i>>v[j];return i;}",
				"template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }",
				"template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }",
				"bool second_compare(P a,P b){if(a.second!=b.second){return a.second<b.second;} else return true;}",
				"",
				"int main() {",
				"    $1",
				"    return 0;",
				"}",
		],
		"description": "Main Template"
	},
	"modPow": {
    "prefix": "modp",
    "body": [
      "int modPow(ll a, ll n, ll p) {",
			"    if (n == 0) return 1;",
			"    if (n == 1) return a % p;",
			"    if (n % 2 == 1) return (a * modPow(a, n - 1, p)) % p;",
			"    ll t = modPow(a, n / 2, p);",
			"    return (t * t) % p;",
			"}",
    ],
    "description": "Mod pow template"
	},
	"prime": {
		"prefix": "primef",
		"body": [
			"vector<PLL> prime_factorize(ll n) {",
			"    vector<PLL> res;",
			"    for (ll i = 2; i*i <= n; i++) {",
			"        if (n%i != 0) continue;",
			"        ll ex = 0;",
			"        while (n%i == 0) {",
			"            ++ex; n /= i;",
			"        }",
			"        res.push_back({i, ex});",
			"    }",
			"    if (n != 1) res.push_back({n, 1});",
			"    return res;",
		  "}",
		],
		"description": "Prime factorize template"
	},
	"UnionFind": {
		"prefix": "unionf",
		"body": [
			"struct UnionFind {",
			"    vector<int> d;",
			"    UnionFind(int n): d(n, -1) {}",
			"    void init(int n) { d.assign(n, -1); }",
			"    int root(int x) {",
			"        if (d[x] < 0) return x;",
			"        else return d[x] = root(d[x]);",
			"    }",
			"    bool unite(int x, int y) {",
			"        x = root(x); y = root(y);",
			"        if (x == y) return false;",
			"        if (d[x] > d[y]) swap(x, y);",
			"        d[x] += d[y];",
			"        d[y] = x;",
			"        return true;",
			"    }",
			"    bool same(int x, int y) { return root(x) == root(y); }",
			"    int size(int x) { return -d[root(x)]; };",
			"};",
		],
		"description": "UnionFind template"
	},
}